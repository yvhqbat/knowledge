# 198.打家劫舍
## 题目描述
```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/house-robber
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 分析
这是一道典型的且简单的动态规划问题。

对于第i个房屋，有两种选择：偷、不偷。
- 如果偷了，则上一家不能偷；
- 如果不偷，则上一家可选择偷或不偷；

可以得出，状态转移方程为： `dp(i)=max(dp[i-1], dp[i-2]+nums[i])`，
时间复杂度为O(n)，空间复杂度为O(n)。

还有优化的空间，类似于斐波那契数列。通过状态转移方程可以看出，dp[i]只依赖于dp[i-1]和dp[i-2]的值，所以只需要使用两个变量保持前两个值即可，空间复杂度降为O(1)。


## 题解
golang code:
```golang
func rob(nums []int) int {
    size := len(nums)
    if size<=0{
        return 0
    }else if size == 1{
        return nums[0]
    }else if size == 2{
        if nums[0]>nums[1]{
            return nums[0]
        }else{
            return nums[1]
        }
    }

    dp := make([]int, size)
    dp[0]=nums[0]
    if nums[0]>nums[1]{
        dp[1]=nums[0]
    }else{
        dp[1]=nums[1]
    }

    for i:=2;i<size;i++{
        if dp[i-1]>dp[i-2]+nums[i]{
            dp[i]=dp[i-1]
        }else{
            dp[i]=dp[i-2]+nums[i]
        }
    }
    return dp[size-1]
}

```

空间优化的代码略。